# Oberon-numeric-case-statement
Numeric CASE statement for the Oberon-07 programming language on Project Oberon 2013 and Extended Oberon.

Note: In this repository, the term "Project Oberon 2013" refers to a re-implementation of the original "Project Oberon" on an FPGA development board around 2013, as published at www.projectoberon.com.

**PREREQUISITES**: A current version of Project Oberon 2013 (see http://www.projectoberon.com). If you use Extended Oberon (see http://github.com/andreaspirklbauer/Oberon-extended), the functionality is already implemented.

------------------------------------------------------
The official Oberon-07 language report (www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf, as of 3.5.2016) allows *numeric* CASE statements, which are however not implemented in the official release at www.projectoberon.com.

The modified Oberon-07 compiler provided in **this** repository brings the compiler in line with the language report, i.e. it also allows *numeric* CASE statements (CASE int|char OF), in addition to *type* CASE statements (CASE pointer|record OF).

Implemented syntax:

     CaseStatement = CASE expression OF case {"|" case} [ELSE StatementSequence] END.
     case          = [CaseLabelList ":" StatementSequence].
     CaseLabelList = LabelRange {"," LabelRange}. 
     LabelRange    = label [".." label].
     label         = integer | string | qualident.

The essential property of the numeric CASE statement is that - in contrast to a cascaded conditional statement - it represents a single, indexed branch, which selects a statement sequence from a set of cases according to an index value. Case statements are recommended only if the set of selectable statements is reasonably large.

Our implementation constructs a "jump table" of branch statements (containing the branch distances as operands) to the various component statements, leading to a *constant* number of instructions for any selection in a CASE statement.

Jump tables are located in the code section of a module. The selection ("switch") in a case statement is generated by procedure *CaseHead* in module *ORG*, which uses the jump table generated by procedure *CaseTail*.

The following rules and restrictions apply for **numeric** case statements:

* Case labels must have values between 0 and 255.
* If the value of the case expression does not correspond to any case label in the source text, the statement sequence following the symbol ELSE is selected, if there is one, otherwise the program is aborted (*if one wants to treat such events as “empty” actions, an empty ELSE clause can be used*).

The ELSE clause has been re-introduced even though it is not part of the Oberon-07 language definition. This was done mainly for backward compatibility reasons. In general, we recommend using the ELSE clause only in well-justified cases, for example if the index range far exceeds the label range. But even in that case, one should first try to find a representation using explicit case label ranges, as shown in the example below (which assumes an index range of 0..255).

     CASE i OF                                     CASE i OF
         1:  S1                                        1:  S1
       | 3:  S3                                      | 3:  S3
       | 7:  S7            is the same as            | 7:  S7           
       | 9:  S9                                      | 9:  S9
     ELSE S0                                         | 0, 2, 4..6, 8, 10..255:  S0    (*preferred*)
     END                                           END

The implementation cost of adding the numeric CASE statement is **~65** lines of source code (*ORG* ~25, *ORP* ~40).

**Implementation details:**

* Jump tables are addressed relative to the program counter (PC), and the branch offset when selecting the component statement is computed at **compile** time.

* The average overhead of any selection in a CASE statement is **9** instructions.

* The ELSE clause is implemented (although it is recommended to use explicit case label ranges whenever possible).

* Case labels must have values between 0 and 255.

* The index expression can have any value (even values outside the range 0 .. 255).

* If the index value does not correspond to any case label, a trap is generated **unless** an ELSE clause is present.

In this implementation, the index range for case expressions of integer type is MIN(INTEGER) .. MAX(INTEGER) and therefore far exceeds the case label range (0 .. 255). In such a case, an ELSE clause *may* be justified, although it is not part of the Oberon-07 language definition. But as outlined above, even in that case one should first try to express a numeric case statement using explicit case label ranges.

-------------------------------------------------------------------------------------

**Variants**:

There are also several alternative variants that have been investigated for purely experimental purposes:

**Variant 1** (use source file *ORG1.Mod* from the subdirectory [**Sources/FPGAOberon2013/Variant1**](Sources/FPGAOberon2013/Variant1), not recommended):

* Jump tables are addressed relative to the program counter (PC), and the branch offset when selecting the component statement is computed at **compile** time.

* The average overhead of any selection in a CASE statement is **9** instructions.

* The ELSE clause is implemented (although superfluous).

* Case labels must have values between 0 and 255.

* The index expression must **also** have values between 0 and 255 **regardless** of whether an ELSE clause is present.

* If the index value is outside 0 .. 255, a trap is generated **even if** an ELSE clause is present.

* If the index value is inside 0 .. 255 and does not correspond to any case label, **no** trap is generated (i.e. such events are treated as "empty" actions).

In this variant, the index range and the case label range are the same (0 .. 255). This means, that the ELSE clause is actually superfluous, as it is always **easy** to find an expression using explicit case label ranges (as shown above).

We do not recommend restricting the index range in this way. If one wants to restrict the index range, CHAR selectors can be used. In addition, the creation of traps (no trap for values 0 .. 255, trap for values outside 0 .. 255) is inconsistent. 

-------------------------------------------------------------------------------------

**Variant 2** (use source files *ORG2.Mod* and *ORP2.Mod* from the subdirectory [**Sources/FPGAOberon2013/Variant2**](Sources/FPGAOberon2013/Variant2), not recommended):

* Jump tables are addressed relative to the program counter (PC), and the branch offset when selecting the component statement is computed at **run** time.

* The average overhead of any selection in a CASE statement is **9** instructions.

* The ELSE clause is **not** implemented.

* Case labels must have values between 0 and 255

* The index expression must have values between 0 and the highest case label range.

* If the index value is outside 0 .. *highest case label range*, a trap is generated.

* If the index value is inside 0 .. *highest case label range* and does not correspond to any case label, **no** trap is generated (i.e. such events are treated as "empty" actions).

In this case, the index range is even more restricted (to 0 .. highest case label range <= 255).

We do not recommend restricting the index range in this way. In addition, the creation of traps (no trap for values 0 .. highest case label range, trap for values outside 0 .. highest label range) is inconsistent. 

-------------------------------------------------------------------------------------

**Variant 3** (not implemented)

* If the branch instruction of the form **B,cond  [Rn]** of the RISC processor, as defined on www.projectoberon.com, were adapted to be of the form **B,cond  PC, [Rn]** (where the target of the branch is computed by adding the contents of a register to the current *program counter*), then the average overhead of any selection in a CASE statement would be **6** instructions (see www.astrobe.com for an example of such a modification of RISC).

------------------------------------------------------

**Preparing your compiler to support the numeric CASE statement**

If *Extended Oberon* is used, the numeric case statement (default version) is already implemented on your system.

If *Project Oberon 2013* is used, follow the instructions below:

------------------------------------------------------

**STEP 1**: Build a slightly modified Oberon compiler on your Project Oberon 2013 system

Edit the file *ORG.Mod* on your original system and set the following constants to the indicated new values:

     CONST ...
       maxCode = 8800; maxStrx = 3200; ...

Then recompile the modified file of your Project Oberon 2013 compiler (and unload the old one):

     ORP.Compile ORG.Mod/s ~
     System.Free ORTool ORP ORG ~

This step is (unfortunately) necessary since the official Oberon-07 compiler has a tick too restrictive constants. To compile the new version of the Oberon-07 compiler, one needs slightly more space (in the compiler) for both *code* and *string constants*.

------------------------------------------------------

**STEP 2**: Download and import the files to implement the numeric case statement to your Project Oberon 2013 system

Download all files from the [**Sources**](Sources/) directory of this repository. Convert the *source* files to Oberon format (Oberon uses CR as line endings) using the command [**dos2oberon**](dos2oberon), also available in this repository (example shown for Linux or MacOS):

     for x in *.Mod ; do ./dos2oberon $x $x ; done

Import the files to your Oberon system. If you use an emulator, click on the *PCLink1.Run* link in the *System.Tool* viewer, copy the files to the emulator directory, and execute the following command on the command shell of your host system:

     cd oberon-risc-emu
     for x in *.Mod ; do ./pcreceive.sh $x ; sleep 0.5 ; done

------------------------------------------------------

**STEP 3:** Build the "new" Oberon-07 compiler (default version):

     ORP.Compile ORG.Mod/s ORP.Mod/s ~
     System.Free ORTool ORP ORG ORB ORS ~

------------------------------------------------------

**Testing the modified CASE statement on your system**

See the file *Test.Mod* in the *Sources* directory of this repository.

------------------------------------------------------
**DIFFERENCES TO THE OFFICIAL OBERON-07 COMPILER**

**$ diff -u FPGAOberon2013/ORG.Mod OberonNumericCaseStatement/ORG.Mod**

```diff
--- FPGAOberon2013/ORG.Mod	2024-12-23 13:44:49
+++ Oberon-numeric-case-statement/Sources/FPGAOberon2013/ORG.Mod	2024-12-23 20:52:51
@@ -1,4 +1,4 @@
-MODULE ORG; (* N.Wirth, 16.4.2016 / 4.4.2017 / 31.5.2019  Oberon compiler; code generator for RISC*)
+MODULE ORG; (* N.Wirth, 16.4.2016 / 4.4.2017 / 17.9.2018  Oberon compiler; code generator for RISC / AP 13.12.24*)
   IMPORT SYSTEM, Files, ORS, ORB;
   (*Code generator for Oberon compiler for RISC processor.
      Procedural interface to Parser ORP; result in array "code".
@@ -7,7 +7,7 @@
   CONST WordSize* = 4;
     StkOrg0 = -64; VarOrg0 = 0;  (*for RISC-0 only*)
     MT = 12; SP = 14; LNK = 15;   (*dedicated registers*)
-    maxCode = 8000; maxStrx = 2400; maxTD = 160; C24 = 1000000H;
+    maxCode = 8800; maxStrx = 3200; maxTD = 160; C16 = 10000H; C24 = 1000000H; C28 = 10000000H; C30 = 40000000H;
     Reg = 10; RegI = 11; Cond = 12;  (*internal item modes*)
 
   (*frequently used opcodes*)  U = 2000H; V = 1000H;
@@ -21,9 +21,11 @@
     TYPE Item* = RECORD
       mode*: INTEGER;
       type*: ORB.Type;
+      obj*: ORB.Object;
       a*, b*, r: LONGINT;
       rdo*: BOOLEAN  (*read only*)
     END ;
+    LabelRange* = RECORD low*, high*, label*: INTEGER END ;
 
   (* Item forms and meaning of fields:
     mode    r      a       b
@@ -51,6 +53,11 @@
 
   (*instruction assemblers according to formats*)
 
+  PROCEDURE incR;
+  BEGIN
+    IF RH < MT-1 THEN INC(RH) ELSE ORS.Mark("register stack overflow") END
+  END incR;
+
   PROCEDURE Put0(op, a, b, c: LONGINT);
   BEGIN (*emit format-0 instruction*)
     code[pc] := ((a*10H + b) * 10H + op) * 10000H + c; INC(pc)
@@ -63,11 +70,17 @@
   END Put1;
 
   PROCEDURE Put1a(op, a, b, im: LONGINT);
-  BEGIN (*same as Put1, but with range test  -10000H <= im < 10000H*)
-    IF (im >= -10000H) & (im <= 0FFFFH) THEN Put1(op, a, b, im)
-    ELSE Put1(Mov+U, RH, 0, im DIV 10000H);
-      IF im MOD 10000H # 0 THEN Put1(Ior, RH, RH, im MOD 10000H) END ;
-      Put0(op, a, b, RH)
+    VAR r: INTEGER;
+  BEGIN (*same as Put1, but with range test -C16 <= im < C16*)
+    IF (im >= -C16) & (im < C16) THEN Put1(op, a, b, im)
+    ELSIF op = Mov THEN
+      Put1(Mov+U, a, 0, im DIV C16);
+      IF im MOD C16 # 0 THEN Put1(Ior, a, a, im MOD C16) END
+    ELSE r := RH;
+      IF (a = RH) OR (b = RH) THEN incR END ;
+      Put1(Mov+U, RH, 0, im DIV C16);
+      IF im MOD C16 # 0 THEN Put1(Ior, RH, RH, im MOD C16) END ;
+      Put0(op, a, b, RH); RH := r
     END
   END Put1a;
 
@@ -81,11 +94,6 @@
     code[pc] := ((op+12) * 10H + cond) * 1000000H + (off MOD 1000000H); INC(pc)
   END Put3;
 
-  PROCEDURE incR;
-  BEGIN
-    IF RH < MT-1 THEN INC(RH) ELSE ORS.Mark("register stack overflow") END
-  END incR;
-
   PROCEDURE CheckRegs*;
   BEGIN
     IF RH # 0 THEN ORS.Mark("Reg Stack"); RH := 0 END ;
@@ -117,21 +125,29 @@
   BEGIN fix(at, pc-at-1)
   END FixOne;
 
-  PROCEDURE FixLink*(L: LONGINT);
-    VAR L1: LONGINT;
-  BEGIN
-    WHILE L # 0 DO L1 := code[L] MOD 40000H; fix(L, pc-L-1); L := L1 END
-  END FixLink;
+  PROCEDURE fix1(at, with: LONGINT);
+    VAR v: LONGINT;
+  BEGIN (*fix format-1 instruction*)
+    IF with < 0 THEN v := C28 (*set v bit*) ELSE v := 0 END ;
+    code[at] := code[at] DIV C16 * C16 + (with MOD C16) + v
+  END fix1;
 
-  PROCEDURE FixLinkWith(L0, dst: LONGINT);
-    VAR L1: LONGINT;
-  BEGIN
-    WHILE L0 # 0 DO
-      L1 := code[L0] MOD C24;
-      code[L0] := code[L0] DIV C24 * C24 + ((dst - L0 - 1) MOD C24); L0 := L1
+  PROCEDURE FixLinkWith(L, dst: LONGINT);
+    VAR L1, k: LONGINT;
+  BEGIN (*fix format-1 and branch instructions*)
+    WHILE L # 0 DO k := code[L] DIV C30 MOD 4;
+      IF k = 1 THEN L1 := code[L] MOD C16; fix1(L, (dst-L)*4)
+      ELSIF k = 3 THEN L1 := code[L] MOD 40000H; fix(L, dst-L-1)
+      ELSE ORS.Mark("fixup impossible"); L1 := 0
+      END ;
+      L := L1
     END
   END FixLinkWith;
 
+  PROCEDURE FixLink*(L: LONGINT);
+  BEGIN FixLinkWith(L, pc)
+  END FixLink;
+
   PROCEDURE merged(L0, L1: LONGINT): LONGINT;
     VAR L2, L3: LONGINT;
   BEGIN (*merge branch instructions*)
@@ -247,7 +263,7 @@
   END MakeStringItem;
 
   PROCEDURE MakeItem*(VAR x: Item; y: ORB.Object; curlev: LONGINT);
-  BEGIN x.mode := y.class; x.type := y.type; x.a := y.val; x.rdo := y.rdo;
+  BEGIN x.obj := y; x.mode := y.class; x.type := y.type; x.a := y.val; x.rdo := y.rdo;
     IF y.class = ORB.Par THEN x.b := 0
     ELSIF (y.class = ORB.Const) & (y.type.form = ORB.String) THEN x.b := y.lev  (*len*)
     ELSE x.r := y.lev
@@ -284,7 +300,7 @@
           ELSE ORS.Mark("error in Index")
           END
         END ;
-        Trap(10, 1)  (*BCC*)
+        Trap(CC, 1)
       END ;
       IF s = 4 THEN Put1(Lsl, y.r, y.r, 2) ELSIF s > 1 THEN Put1a(Mul, y.r, y.r, s) END ;
       IF x.mode = ORB.Var THEN
@@ -666,9 +682,9 @@
     Put2(Str, RH, x.r, 0); Put1(Add, x.r, x.r, 4);
     Put1(Asr, RH, RH, 24); Put3(BC, NE,  -6);  RH := 0
    END CopyString;
-  
+
   (* Code generation for parameters *)
-  
+
   PROCEDURE OpenArrayParam*(VAR x: Item);
   BEGIN loadAdr(x);
     IF x.type.len >= 0 THEN Put1a(Mov, RH, 0, x.type.len) ELSE Put2(Ldr, RH, SP, x.a+4+frame) END ;
@@ -818,8 +834,34 @@
     RH := 0
   END Return;
 
-  (* In-line code procedures*)
+  (* Case Statements *)
+
+  PROCEDURE CaseHead*(VAR x: Item; VAR L0: LONGINT);
+  BEGIN load(x);  (*value of case expression*)
+    L0 := pc; Put1(Cmp, RH, x.r, 0);  (*higher bound, fixed up in CaseTail*)
+    Put3(BC, CC, 0);  (*branch to else, fixed up in CaseTail*)
+    Put1(Add, x.r, x.r, 0);  (*nof words between BL instruction at L0+4 and jump table, fixed up in CaseTail*)
+    Put1(Lsl, x.r, x.r, 2);
+    (*L0+4*) Put3(BL, 7, 0);  (*LNK := PC+1*)
+    Put0(Add, LNK, LNK, x.r); Put3(BR, 7, LNK); DEC(RH)
+  END CaseHead;
 
+  PROCEDURE CaseTail*(L0, L1: LONGINT; n: INTEGER; VAR tab: ARRAY OF LabelRange);  (*L1 = label for else*)
+    VAR i, j: INTEGER;
+  BEGIN
+    IF n > 0 THEN fix1(L0, tab[n-1].high + 1) (*higher bound*) ELSIF L1 = 0 THEN ORS.Mark("empty case") END ;
+    IF L1 = 0 THEN L1 := pc; Trap(7, 1) END ;  (*create else*)
+    fix(L0+1, L1-L0-2);  (*branch to else*)
+    fix1(L0+2, pc-L0-5);  (*nof words between BL instruction at L0+4 and jump table*)
+    j := 0;
+    FOR i := 0 TO n-1 DO  (*construct jump table*)
+      WHILE j < tab[i].low DO BJump(L1); INC(j) END ;  (*else*)
+      WHILE j <= tab[i].high DO BJump(tab[i].label); INC(j) END
+    END
+  END CaseTail;
+
+  (* In-line code procedures *)
+
   PROCEDURE Increment*(upordown: LONGINT; VAR x, y: Item);
     VAR op, zr, v: LONGINT;
   BEGIN (*frame = 0*)
@@ -1064,6 +1106,7 @@
       obj := obj.next
     END ;
     size := varsize + strx + comsize + (pc + nofimps + nofent + nofptrs + 1)*4;  (*varsize includes type descriptors*)
+
     ORB.MakeFileName(name, modid, ".rsc"); (*write code file*)
     F := Files.New(name); Files.Set(R, F, 0); Files.WriteString(R, modid); Files.WriteInt(R, key); Files.Write(R, CHR(version));
     Files.WriteInt(R, size);
```

**$ diff -u FPGAOberon2013/ORP.Mod OberonNumericCaseStatement/ORP.Mod**

```diff
--- FPGAOberon2013/ORP.Mod	2021-05-24 10:06:15
+++ Oberon-numeric-case-statement/Sources/FPGAOberon2013/ORP.Mod	2024-12-23 23:16:11
@@ -1,10 +1,12 @@
-MODULE ORP; (*N. Wirth 1.7.97 / 8.3.2020  Oberon compiler for RISC in Oberon-07*)
+MODULE ORP; (*N. Wirth 1.7.97 / 8.3.2020  Oberon compiler for RISC in Oberon-07 / AP 13.12.24*)
   IMPORT Texts, Oberon, ORS, ORB, ORG;
   (*Author: Niklaus Wirth, 2014.
     Parser of Oberon-RISC compiler. Uses Scanner ORS to obtain symbols (tokens),
     ORB for definition of data structures and for handling import and export, and
     ORG to produce binary code. ORP performs type checking and data allocation.
     Parser is target-independent, except for part of the handling of allocations.*)
+
+  CONST NofCases = 256;
 
   TYPE PtrBase = POINTER TO PtrBaseDesc;
     PtrBaseDesc = RECORD  (*list of names of pointer base types*)
@@ -157,7 +159,8 @@
         ELSE ORS.Mark("not an identifier")
         END ;
         Check(ORS.rparen, " ) missing")
-      END
+      END ;
+      x.obj := NIL
     END
   END selector;
 
@@ -462,33 +465,91 @@
 
   PROCEDURE StatSequence;
     VAR obj: ORB.Object;
-      orgtype: ORB.Type; (*original type of case var*)
       x, y, z, w: ORG.Item;
       L0, L1, rx: LONGINT;
 
-    PROCEDURE TypeCase(obj: ORB.Object; VAR x: ORG.Item);
-      VAR typobj: ORB.Object;
+    PROCEDURE TypeCase(obj: ORB.Object; VAR L0: LONGINT);
+      VAR typobj: ORB.Object; x: ORG.Item;
+        orgtype: ORB.Type;  (*original type of case var*)
     BEGIN
       IF sym = ORS.ident THEN
-        qualident(typobj); ORG.MakeItem(x, obj, level);
+        qualident(typobj); ORG.MakeItem(x, obj, level); orgtype := obj.type;
         IF typobj.class # ORB.Typ THEN ORS.Mark("not a type") END ;
         TypeTest(x, typobj.type, FALSE); obj.type := typobj.type;
-        ORG.CFJump(x); Check(ORS.colon, ": expected"); StatSequence
-      ELSE ORG.CFJump(x); ORS.Mark("type id expected")
+        ORG.CFJump(x); Check(ORS.colon, ": expected"); StatSequence;
+        ORG.FJump(L0); ORG.Fixup(x); obj.type := orgtype;
+      ELSE ORS.Mark("type id expected"); Check(ORS.colon, ": expected"); StatSequence
       END
-     END TypeCase;
+    END TypeCase;
 
+    PROCEDURE TypeCasePart(obj: ORB.Object);
+      VAR L0: LONGINT;
+    BEGIN Check(ORS.of, "OF expected"); L0 := 0;
+      WHILE (sym < ORS.end) OR (sym = ORS.bar) DO
+        IF sym = ORS.bar THEN ORS.Get(sym) ELSE TypeCase(obj, L0) END
+      END ;
+      IF sym = ORS.else THEN ORS.Get(sym); StatSequence END ;
+      ORG.FixLink(L0)
+    END TypeCasePart;
+
+    PROCEDURE CaseLabel(VAR x: ORG.Item);
+    BEGIN expression(x); CheckConst(x);
+      IF (x.type.form = ORB.String) & (x.b = 2) THEN ORG.StrToChar(x)
+      ELSIF ~(x.type.form IN {ORB.Int, ORB.Char}) OR (x.a < 0) OR (x.a > 255) THEN
+        ORS.Mark("invalid case label"); x.type := ORB.intType
+      END
+    END CaseLabel;
+
+    PROCEDURE NumericCase(LabelForm: INTEGER; VAR n: INTEGER; VAR tab: ARRAY OF ORG.LabelRange);
+      VAR x, y: ORG.Item; i: INTEGER;
+    BEGIN
+      REPEAT CaseLabel(x);
+        IF x.type.form # LabelForm THEN ORS.Mark("invalid label form") END ;
+        IF sym = ORS.upto THEN ORS.Get(sym); CaseLabel(y);
+          IF (x.type.form # y.type.form) OR (x.a >= y.a) THEN ORS.Mark("invalid label range"); y := x END
+        ELSE y := x
+        END ;
+        IF n < NofCases THEN (*enter label range into ordered table*) i := n;
+          WHILE (i > 0) & (tab[i-1].low > y.a) DO tab[i] := tab[i-1]; DEC(i) END ;
+          IF (i > 0) & (tab[i-1].high >= x.a) THEN ORS.Mark("overlapping case labels") END ;
+          tab[i].low := x.a; tab[i].high := y.a; tab[i].label := ORG.Here(); INC(n)
+        ELSE ORS.Mark("too many case labels")
+        END ;
+        IF sym = ORS.comma THEN ORS.Get(sym)
+        ELSIF (sym < ORS.comma) OR (sym = ORS.semicolon) THEN ORS.Mark("comma?")
+        END
+      UNTIL (sym > ORS.comma) & (sym # ORS.semicolon);
+      Check(ORS.colon, ": expected"); StatSequence
+    END NumericCase;
+
+    PROCEDURE NumericCasePart(VAR x: ORG.Item);
+      VAR L0, L1, L2: LONGINT; n, labelform: INTEGER;
+        tab: ARRAY NofCases OF ORG.LabelRange;  (*ordered table of label ranges*)
+    BEGIN Check(ORS.of, "OF expected"); ORG.CaseHead(x, L0); n := 0; L2 := 0; labelform := x.type.form;
+      WHILE (sym < ORS.end) OR (sym = ORS.bar) DO
+        IF sym = ORS.bar THEN ORS.Get(sym) ELSE NumericCase(labelform, n, tab); ORG.FJump(L2) END
+      END ;
+      IF sym = ORS.else THEN ORS.Get(sym); L1 := ORG.Here(); StatSequence; ORG.FJump(L2) ELSE L1 := 0 END ;
+      ORG.CaseTail(L0, L1, n, tab); ORG.FixLink(L2)
+    END NumericCasePart;
+
     PROCEDURE SkipCase;
-    BEGIN 
-      WHILE sym # ORS.colon DO ORS.Get(sym) END ;
-      ORS.Get(sym); StatSequence
+      VAR obj: ORB.Object;
+    BEGIN Check(ORS.of, "OF expected");
+      WHILE (sym < ORS.end) OR (sym = ORS.bar) DO
+        IF sym = ORS.bar THEN ORS.Get(sym)
+        ELSE (*type case assumed*)
+          IF sym = ORS.ident THEN qualident(obj) END ;
+          Check(ORS.colon, ": expected"); StatSequence
+        END
+      END ;
+      IF sym = ORS.else THEN ORS.Get(sym); StatSequence END
     END SkipCase;
 
   BEGIN (* StatSequence *)
     REPEAT (*sync*) obj := NIL;
-      IF ~((sym >= ORS.ident)  & (sym <= ORS.for) OR (sym >= ORS.semicolon)) THEN
-        ORS.Mark("statement expected");
-        REPEAT ORS.Get(sym) UNTIL (sym >= ORS.ident)
+      IF ~((sym >= ORS.ident) & (sym <= ORS.for) OR (sym >= ORS.semicolon)) THEN ORS.Mark("statement expected");
+        REPEAT ORS.Get(sym) UNTIL sym >= ORS.ident
       END ;
       IF sym = ORS.ident THEN
         qualident(obj); ORG.MakeItem(x, obj, level);
@@ -567,20 +628,12 @@
         ELSE ORS.Mark("identifier expected")
         END
       ELSIF sym = ORS.case THEN
-        ORS.Get(sym);
-        IF sym = ORS.ident THEN
-          qualident(obj); orgtype := obj.type;
-          IF (orgtype.form = ORB.Pointer) OR (orgtype.form = ORB.Record) & (obj.class = ORB.Par) THEN
-            Check(ORS.of, "OF expected"); TypeCase(obj, x); L0 := 0;
-            WHILE sym = ORS.bar DO
-              ORS.Get(sym); ORG.FJump(L0); ORG.Fixup(x); obj.type := orgtype; TypeCase(obj, x)
-            END ;
-            ORG.Fixup(x); ORG.FixLink(L0); obj.type := orgtype
-          ELSE ORS.Mark("numeric case not implemented");
-            Check(ORS.of, "OF expected"); SkipCase;
-            WHILE sym = ORS.bar DO SkipCase END
-          END
-        ELSE ORS.Mark("ident expected")
+        ORS.Get(sym); x.obj := NIL; expression(x);
+        IF x.type.form IN {ORB.Int, ORB.Byte, ORB.Char} THEN NumericCasePart(x)
+        ELSIF (x.obj # NIL) &
+          ((x.type.form = ORB.Pointer) & (x.type.base.form = ORB.Record) OR
+          (x.type.form = ORB.Record) & (x.mode = ORB.Par)) THEN TypeCasePart(x.obj)
+        ELSE ORS.Mark("invalid case variable"); SkipCase
         END ;
         Check(ORS.end, "no END")
       END ;
@@ -608,7 +661,7 @@
     ELSE first := NIL
     END
   END IdentList;
-
+  
   PROCEDURE ArrayType(VAR type: ORB.Type);
     VAR x: ORG.Item; typ: ORB.Type; len: LONGINT;
   BEGIN NEW(typ); typ.form := ORB.NoTyp;
@@ -994,7 +1047,7 @@
     Oberon.Collect(0)
   END Compile;
 
-BEGIN Texts.OpenWriter(W); Texts.WriteString(W, "OR Compiler  8.3.2020");
+BEGIN Texts.OpenWriter(W); Texts.WriteString(W, "OR Compiler  8.3.2020 / AP 13.12.24");
   Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
   NEW(dummy); dummy.class := ORB.Var; dummy.type := ORB.intType;
   expression := expression0; Type := Type0; FormalType := FormalType0
```

